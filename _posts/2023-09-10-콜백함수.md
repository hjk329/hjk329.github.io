---
title:  "자바스크립트의 콜백함수"
categories: 
  - Books
  - Javascript
tags:
  - 콜백함수
  - 비동기
  - 동기
  - Web API
  - Promise
  - Async
  - Await
  - 이벤트 루프
toc: true
toc_sticky: true
toc_label: "자바스크립트의 콜백함수"
share: true
published: false
---

# 콜백함수란?
콜백함수는 다른 함수에 인자로 전달되는 함수를 의미한다.

이때 아래에 대한 `제어권` 을 다른 함수에 넘겨준다

- 콜백함수가 언제 호출될지
- 콜백함수를 호출할때 인자에 어떤 값들을 어떤 순서로 넘길지
- 콜백함수 내부에서 사용될 this


# 콜백함수와 비동기

비동기란 특정 코드의 연산이 끝날 때까지 기다리지 않고 다음 코드를 실행하는 것을 의미한다.  

반대로, 특정 작업이 완료될때까지 기다렸다가 다음 코드를 실행하는 것을 동기 처리라고 한다.  

즉, 동기 처리 방식은 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장된다는 장점이 있지만, 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹되는 단점이 있다. 

비동기 처리를 하면 특정 작업이 완료되었을때 해야할 일을 미리 정의해두고, 다음 코드를 먼저 실행하기 때문에 시간이 오래 걸리는 작업이더라도 메인 스레드를 차단하지 않고, 사용자는 웹 어플리케이션을 계속 사용할 수 있다.  

그리고 특정 작업이 완료되었을때 해야 할 일을 정의하기 위해 콜백함수를 넘겨준다.  

콜백함수를 호출하는 함수에서 콜백함수의 호출 시점에 대한 제어권을 갖기 때문에 작업이 완료되었을 시점에서 콜백함수를 호출하도록 할 수 있기 때문이다.  

하지만, 이러한 콜백함수도 항상 만능은 아니다. 🥸  

# 콜백함수 기반의 비동기 처리가 가진 한계

1. **비동기 실행 흐름의 제어**

콜백함수를 사용하는 비동기 작업들은 독립적으로 실행되므로 특정 순서로 비동기 작업들을 제어하거나, 전체 작업이 완료되었는지 파악하기 어려워진다.  

```js
let count = 0;
const total = 2;

asyncFunction1(params, function(err, result) {
    if (err) {
        console.error('Error:', err);
    } else {
        // 개별 작업이 정상적으로 완료되면 해야할 동작
        count++;
        if (count === total) {
            // 모든 비동기 처리가 완료되면 해야할 동작
        }
    }
});

asyncFunction2(params, function(err, result) {
    if (err) {
        console.error('Error:', err);
    } else {
        // 개별 작업이 정상적으로 완료되면 해야할 동작
        count++;
        if (count === total) {
            // 모든 비동기 처리가 완료되면 해야할 동작
        }
    }
});
```



2. **에러 처리의 어려움**  
콜백함수가 많아질 수록 예외처리가 복잡해질 수 있다.

`setTimeout` 에 전달된 콜백함수는 비동기로 처리되고, try catch 문은 **동기적으로** 실행되며 try 블록 내에서 직접 실행한 코드에서 발생한 예외를 캐치할 수 있다.
`setTimeout` 에 전달된 콜백함수가 비동기적으로 처리되었을 시점에 try catch 문은 이미 실행을 종료한 상태일 것이다. 이를 방지하기 위해 콜백 함수 내부에서 직접 예외를 핸들링해야 한다.

```js
// BAD

try {
  setTimeout(() => {throw new Error('에러를 뱉어주세요!!!')}, 1000)
} catch (err) {
  console.log('에러', err)
}

// GOOD
setTimeout(() => {
  try {
    throw new Error('ERROR');
  } catch (e) {
    console.log('에러를 캐치했습니다'); // 에러를 캐치했습니다
    console.log(e); // Error: ERROR
  }
}, 1000);
```


3. **콜백 지옥** .. 👾
비동기 로직이 복잡해지면서 콜백함수를 중첩해서 사용하면 코드의 가독성이 떨어지고, 디버깅도 어려워진다


```js
step1(function(value1) {
    step2(value1, function(value2) {
        step3(value2, function(value3) {
            step4(value3, function(result) {
                // Do something with the result.
            });
        });
    });
});
```


위 문제를 해결하기 위해 ES6에서 `Promise` 가 등장했다 ✨
