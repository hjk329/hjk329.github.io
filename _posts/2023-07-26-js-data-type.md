---
title:  "데이터 타입"
categories: 
  - Javascript
  - Books
tags:
  - 데이터 타입
  - 원시 타입
  - 참조 타입
  - 불변성
  - 스택
  - 힙
  - 코어 자바스크립트
toc: true
toc_sticky: true
toc_label: "자바스크립트의 데이터 타입"
share: true
published: false

---

`정재남` 님의 `코어자바스크립트` 를 읽고 정리한 글입니다.  

# 자바스크립트의 데이터 타입

자바스크립트의 데이터 타입은 크게 원시 타입, 참조 타입으로 나뉜다.  

원시 타입에는 String, Number, Boolean, Null, Undefined, Symbol 등이 있다.  

참조 타입으로는 Object, Array, Function, Date 등이 있다.   

원시 타입과 참조 타입은 데이터를 할당하는 과정에서 차이가 있다.  

데이터를 할당한다는 것은 우리가 원하는 값을 메모리 공간에 저장하고, 해당 값을 변수에 할당하는 과정을 말한다.  

# 원시 타입 데이터의 할당

원시 타입 데이터는 `Stack (이하 스택)` 영역에 저장된다.  

스택 영역에는 `크기가 고정적인 값`이 저장되므로 불변성을 가진 원시 타입 데이터가 저장되기에 알맞다.  

> 불변성이란 한번 메모리 공간에 저장된 데이터의 `값` 이 변할 수 없는 성질을 의미한다.

불변성을 가지는 데이터는 크기가 고정적이므로 정적인 데이터에 해당하여 스택 영역에 저장되는 것이 유리하다.  

```js
var a = 23;
a = 3;
```

자바스크립트 엔진이 위 코드를 평가하고 실행하는 과정을 간략하게 따라가보자! 👀

자바스크립트 엔진은 스택 메모리 영역에 23이라는 값이 있는지 검색하고, 없다면 23을 저장할 공간을 확보한다.    

해당 공간의 `주소값`을 식별자 a와 연결한다.  

즉, 식별자 a는 23이라는 데이터가 저장된 스택 영역의 주솟값을 참조한다.  

식별자 a 에 3이라는 값을 재할당한다면 23이라는 숫자가 3으로 변하는 것이 아니다. 

자바스크립트 엔진은 스택 메모리 영역에 3이라는 값이 있는지 확인하고, 없다면 3을 저장할 공간을 확보한다.  

이후에 식별자 a 의 주소값을 3을 저장한 주소값으로 변경한다.  

즉, 23이라는 값 자체가 3으로 변경된 것이 아니라 식별자 a 가 참조하는 주소값만 달라졌다.  

따라서, 원시 타입 데이터는 **불변하다**.    

그리고, 한번 메모리 공간에 할당된 원시 타입의 값은 값 자체가 불변하므로 고정적인 크기를 가진다.  

함수의 호출이 종료되면 스택 영역에 저장된 값도 제거된다.  


# 참조 타입 데이터의 할당

반면에 참조 타입 데이터는 힙 메모리에 저장된다.  

스택 메모리에는 힙 메모리에 저장된 값을 참조할 수 있는 `주솟값` 이 저장된다.  그리고, 우리가 선언한 변수는 스택 메모리 영역의 주솟값을 참조한다.  

힙 메모리는 동적인 데이터를 저장한다. 이는 힙 메모리에 저장되는 데이터는 그 크기가 가변적이라는 의미이다.  

예를 들어, 참조 타입 데이터인 배열은 요소를 추가하거나 제거함으로써 배열의 크기가 변한다.  


```js

var obj = {
	name: 'hj',
	age: 1234
};

var copyObj = obj;

copyObj.age = 2;

console.log(obj === copyObj); // true
```

copyObj 는 obj 와 같은 주솟값을 참조한다.  

그리고, copyObj 객체의 age 프로퍼티 값을 수정할때 자바스크립트는 obj 가 참조하는 힙 메모리에서 age 프로퍼티의 값만 수정한다.  

이때 스택 메모리에 저장된 obj 가 참조하고 있던 주솟값은 변하지 않았다.  

어떤 객체를 복사한 후에 복사한 객체에서 `프로퍼티 값`을 수정했을때 원본 객체의 프로퍼티 값도 같이 변경되는 이유가 이 때문이다.  

참조 타입 데이터는 내부의 프로퍼티를 변경하는 경우 가변적이다.  

‼️ 아예 새로운 객체를 할당하면 복사된 원본 객체가 변하지 않는다. 서로 다른 주솟값을 바라보기 때문이다.  

```js
var obj1 = {
	name: 'hj',
	mbti: 'esfp'
};

var obj2 = obj1;

obj2 = {
	name: 'eden',
	mbti: 'intj'
}

console.log(obj === obj2); // false
```

따라서, 참조 타입 데이터를 불변성을 유지하며 사용하려면 새로운 객체로 반환하는 것이 중요하겠다.  

교재에서는 함수의 프로퍼티 내부까지 완전히 새로운 객체로 복제하는 `깊은 복사` 의 예제 코드를 아래와 같이 제공한다.  

```js
var copyObjDeep = function(target){
	var newObj = {};

	if(typeof target === 'object' && target !== null){
		for(var prop in target){
			newObj[prop] = copyObjDeep(target[prop]);
  }
 } else {
		newObj = target;
	}
		return newObj;
};
```
