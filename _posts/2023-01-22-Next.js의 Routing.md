---
title:  "Next.js의 Routing"
categories: 
  - Next.js
tags:
  - Routing
  - Router
  - Dynamic Routing
  - 동적 라우팅
  - Shallow Routing
  - location.replace()
  - router.push()
  - getServerSideProps
toc: true
toc_sticky: true
toc_label: "Next.js의 Routing"
share: true
---

Next.js의 Routing을 알아보자! 💌  

### 라우팅이란?
라우팅은 네트워크 용어로서 네트워크상의 주소로 이동하여 해당 주소에 연결되어있는 데이터를 사용하는 일련의 과정을 의미한다.  
라우터는 라우팅을 수행할 수 있는 장치이다.    


리액트에서는 라우터를 제공하지 않기 때문에 `react-router-dom`이라는 패키지를 설치하여 사용한다.    



```javascript
import React from 'react';
import { Switch, Route } from 'react-router-dom';

import Home from './pages/Home';
import HeaderContainer from './views/shared/containers/HeaderContainer';
import { GlobalStyle } from './styled/GlobalStyle';
import Watch from './pages/Watch';
import Search from './pages/Search';
import SidebarContainer from './views/shared/containers/SidebarContainer';
import SidebarGuide from './views/shared/components/Sidebar/components/SidebarGuide';

const App = () => (
  <Container>
    <GlobalStyle />
    <HeaderContainer />
    <SidebarContainer />
    <Template>
      <SidebarGuide />
      <Main>
        <Switch>
          <Route exact path="/" component={Home} />
          <Route exact path="/watch/:id" component={Watch} />
          <Route exact path="/results/:query" component={Search} />
        </Switch>
      </Main>
    </Template>
  </Container>
)

const Template = styled.div`
  display: flex;
`;

const Main = styled.div`
  flex: 1;
`;
export default App;
```

리액트로 유튜브 웹 사이트를 클론 코딩해본 적이 있는데 (`react-router-dom` v6 이전에 작성한 코드입니다)   
위와 같이 각 컴포넌트를 `Route`라는 태그로 감싸서 path를 지정해주었다.  



Next.js가 `pages` (혹은 `src/pages`) 폴더 아래에 파일을 추가하는 방식으로 각 컴포넌트에 URL을 부여하는 것과 크게 다르다 👀  
이러한 차이점이 리액트는 라이브러리, Next.js는 프레임워크라고 하는 근거라고 생각한다.    



리액트는 라우터를 설정하기 위해 개발자가 직접 라우터와 관련한 코드를 작성하고 해당 코드가 호출되어 URL을 분기처리해준다.  
반면에 Next.js는 해당 프레임워크에서 정해둔 방식대로 페이지 파일을 생성하면 해당 파일이 라우터 역할을 한다. (제어의 역전이 발생한다.)    




***참고! `pages` vs `src/pages`***
`pages` 폴더가 `src/pages` 폴더보다 우선권을 갖는다.  
즉, 두 폴더가 모두 존재하는 경우 `pages` 폴더에서 작성한 코드가 우선적으로 적용되고, `src/pages` 폴더 내부는 무시된다.    




### Next.js 에서 생성한 페이지 파일은 아래와 같이 라우팅된다.  

1. Index Routes

- `pages/index.js` → `/`
- `pages/blog/index.js` → `/blog`

2. Nested Routes
- `pages/blog/first-post.js` → `/blog/first-post`
- `pages/dashboard/settings/username.js` → `/dashboard/settings/username`

3. Dynamic Routes
- `pages/blog/[slug].js` → `/blog/:slug (/blog/hello-world)`
- `pages/[username]/settings.js` → `/:username/settings (/foo/settings)`
- `pages/post/[...all].js` → `/post/* (/post/2020/id/title)`

router 객체에 접근하기 위해서는 `useRouter`라는 훅을 사용하면 된다.  
페이지 컴포넌트간의 연결은 `Link` 태그를 사용할 수 있다.  


### 동적 라우팅 (Dynamic Routing)
항상 미리 정의된 경로를 사용할 수 있는 것은 아니다.  
예를 들어, 블로그 게시물의 경로는 `/blog/1`, `/blog/2` … 와 같을텐데 모든 경로에 대해 미리 정의하거나 페이지 컴포넌트를 생성하는 일은 굉장히 비효율적이고, 정확하지 않을 수 있다.    




이때 사용하는 것이 동적 라우팅이다.  
페이지 파일을 생성할때 대괄호를 추가하면 해당 페이지 컴포넌트는 동적으로 라우팅된다.  

- `pages/post/[pid].js`

```javascript
import { useRouter } from 'next/router'

const Post = () => {
  const router = useRouter()
  const { pid } = router.query

  return <p>Post: {pid}</p>
}

export default Post
```

이때 query 객체는 아래와 같은 값을 가진다.  
```
{ "pid": "abc" }
```

- `/post/abc?foo=bar`

```
{"pid": "abc", "foo": "bar"}
```

- `pages/post/[pid]/[comment].js에 대한 경로가 /post/abc/a-comment인 경우`

```
{ "pid": "abc", "comment": "a-comment" }
```

클라이언트 사이드에서 동적 경로에 대해 접근하기 위해서는 `next/link`가 사용된다.  
```javascript
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link href="/post/abc">Go to pages/post/[pid].js</Link>
      </li>
      <li>
        <Link href="/post/abc?foo=bar">Also goes to pages/post/[pid].js</Link>
      </li>
      <li>
        <Link href="/post/abc/a-comment">
          Go to pages/post/[pid]/[comment].js
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

이외에도 `router.push` 같은 메소드를 사용할 수도 있다!  






#### 모든 경로 캐치하기 (Catch All Routes)
대괄호 안에 `...`를 추가하면 모든 경로를 캐치할 수 있다.  

예를 들어, `pages/post/[...slug].js` 는 `post/a` 뿐만 아니라, `post/a/b`, `post/a/b/c`, `post/a/b/c/d` 등 모든 경로를 캐치할 수 있다.  
query 객체 안에 slug라는 프로퍼티는 배열이며, 아래와 같은 값을 가진다.  

```javascript
import { useRouter } from "next/router";

const Post = () => {
    const router = useRouter();
    const {slug} = router.query;
    console.log(slug)
    return <h1>Post</h1>
}

export default Post;
```
<br><br>


<img width="672" alt="image" src="https://user-images.githubusercontent.com/84058944/213975470-fc687d5c-8f55-4c6f-b1ec-e8d03ec1d696.png">      

<br><br>

<img width="672" alt="image" src="https://user-images.githubusercontent.com/84058944/213975646-a6c2b21c-e8af-4957-b46d-2d5c91fd2332.png">


#### 선택적으로 모든 경로 캐치하기 (Optional Catch All Routes)
`[[...slug]]` 이렇게 더블 브라켓을 사용하면 Catch All 경로를 선택적으로 만들 수 있다.  
Catch All과의 다른 점은 매개변수가 없는 경로도 일치하는 점이다.  

- Optional Catch All Routes
<img width="404" alt="image" src="https://user-images.githubusercontent.com/84058944/213976134-fb36e0b1-276f-4cdf-9555-e538c404464d.png">

<br><br>

- Catch All Routes
<img width="804" alt="image" src="https://user-images.githubusercontent.com/84058944/213976251-bcb4aaad-ae0d-48ae-b491-243279d6f85a.png">



<br><br>




### Shallow Routing
Shallow Routing은 `getServerSideProps`, `getStaticProps` 등의 메소드를 다시 실행해서 새롭게 데이터 패칭을 하지 않으면서 URL을 변경할 수 있도록 한다.  
즉, 현재 상태를 잃지 않고 URL만 변경할 수 있다.  

URL을 변경하는 방식 몇개를 살펴보자.  

* `location.replace('url')`

  -`pages/my-page/info.js` 에 아래와 같이 코드를 작성했다.   


```javascript
import { useRouter } from "next/router";
import { useState } from "react";

const Info = () => {
    const router = useRouter()
    const [clicked, setClicked] = useState(false);
    const {status = 'initial'} = router.query;
    
    return <>
    <h1>Info</h1>
    <h1>Clicked: {String(clicked)}</h1>
    <h1>Status: {status}</h1>
    <button onClick={
        ()=> {
            alert('clicked');
            setClicked(true);
            location.replace('/my-page/info?status=editing')
        }
    
    }>edit(location.replace)</button>
    </>
}

export default Info;
```

---
 
브라우저에서 확인해보자! 👀  
- 버튼을 클릭하면 alert이 뜬다.
- Clicked: true 로 변경이 된다.
- URL이 `'/my-page/info?status=editing'` 로 변경되면서 clicked 값이 false 로 다시 변경된다.

즉, URL을 변경하면서 리렌더가 발생했고, 기존의 state를 유지하지 못했다.  

---

* `router.push(url)`
  - `pages/my-page/info.js` 에 아래와 같이 코드를 작성했다.   

```javascript
import { useRouter } from "next/router";
import { useState } from "react";

const Info = () => {
    const router = useRouter()
    const [clicked, setClicked] = useState(false);
    const {status = 'initial'} = router.query;
    
    return <>
    <h1>Info</h1>
    <h1>Clicked: {String(clicked)}</h1>
    <h1>Status: {status}</h1>
    <button onClick={
        ()=> {
            alert('clicked');
            setClicked(true);
            router.push('/my-page/info?status=editing')
        }
    
    }>edit(router.push)</button>
    </>
}

export default Info;
```

---

브라우저에서 확인해보자! 👀  
- 버튼을 클릭하면 alert이 뜬다.
- Clicked: true 로 변경이 된다.
- URL이 `'/my-page/info?status=editing'` 로 변경되어도 clicked  true 로 유지된다.

---

`location.replace()` 메소드와, `router.push()` 메소드를 사용하면서 `getServerSideProps` 함수도 호출해보자! 
```javascript
import { useRouter } from "next/router";
import { useState } from "react";

export async function getServerSideProps() {
    console.log('server-side');
    return {
        props: {}
    }
}

const Info = () => {
    const router = useRouter()
    const [clicked, setClicked] = useState(false);
    const {status = 'initial'} = router.query;
    
    return <>
    <h1>Info</h1>
    <h1>Clicked: {String(clicked)}</h1>
    <h1>Status: {status}</h1>
    

    <button onClick={
        ()=> {
            alert('clicked');
            setClicked(true);
            location.replace('/my-page/info?status=editing')
        }
    
    }>edit(location.replace)</button>

    <button onClick={
        ()=> {
            alert('clicked');
            setClicked(true);
            router.push('/my-page/info?status=editing')
        }
    
    }>edit(router.push)</button>
    </>
}

export default Info;
```
---

브라우저에서 확인해보자! 👀  
- 버튼을 클릭하면 alert이 뜬다.
- Clicked: true 로 변경이 된다.
- URL이 `'/my-page/info?status=editing'` 로 변경되어도 clicked  true 로 유지된다.
- IDE의 터미널에 'server-side'가 찍혔다.  


이는 URL이 변경되면서 `getServerSideProps` 함수가 실행되면서 새로 데이터를 패칭했다는 것을 의미한다.  

---

* `router.push(url, as, {shallow: true})`
  - `pages/my-page/info.js` 에 아래와 같이 코드를 작성했다.   


```javascript
import { useRouter } from "next/router";
import { useState } from "react";

export async function getServerSideProps() {
    console.log('server-side');
    return {
        props: {}
    }
}

const Info = () => {
    const router = useRouter()
    const [clicked, setClicked] = useState(false);
    const {status = 'initial'} = router.query;
    
    return <>
    <h1>Info</h1>
    <h1>Clicked: {String(clicked)}</h1>
    <h1>Status: {status}</h1>
    

    <button onClick={
        ()=> {
            alert('clicked');
            setClicked(true);
            location.replace('/my-page/info?status=editing')
        }
    
    }>edit(location.replace)</button>

    <button onClick={
        ()=> {
            alert('clicked');
            setClicked(true);
            router.push('/my-page/info?status=editing')
        }
    
    }>edit(router.push)</button>



<button onClick={
        ()=> {
            alert('clicked');
            setClicked(true);
            router.push('/my-page/info?status=editing', undefined, {shallow:true})
        }
    
    }>edit(router.push)</button>
    </>



}

export default Info;
```

--- 

브라우저에서 확인해보자! 👀
- 버튼을 클릭하면 alert이 뜬다.
- Clicked: true 로 변경이 된다.
- URL이 `'/my-page/info?status=editing'` 로 변경되어도 clicked  true 로 유지된다.
- IDE의 터미널에 아무것도 기록되지 않았다.  

즉, 로컬 state와 데이터 패칭이 유지되었다.  
따라서, 로컬 state을 유지하고, 데이터 패칭이 새로 발생하지 않으면서, 같은 페이지 내에서 query만 변경하고 싶다면 `Shallow Routing`을 사용할 수 있겠다.  

---


> Next.js 완전 정복 : 확장성 높은 커머스 서비스 구축하기, 최지민 님의 강의를 참고하여 작성한 글입니다.
