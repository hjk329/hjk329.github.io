---
title:  "[코어 자바스크립트] 01 데이터 타입"
categories: 
  - Javascript
  - Books
tags:
  - Javascript
  - 데이터 타입
toc: true
toc_sticky: true
toc_label: "자바스크립트의 데이터 타입"
---

코어 자바스크립트(정재남 지음, 위키북스)를 읽고 정리한 내용입니다.

## 01 데이터 타입의 종류
자바스크립트의 데이터 타입은 크게 두 종류가 있다.
1. 원시 타입(Primitie type)
- 숫자(number), 문자열(string), 불리언(boolean), null, undefined, Symbol
2. 참조 타입(Reference type)
- 객체(Object),  배열(Array), 함수(Function), 날짜(Date), 정규표현식(RegExp), Map, WeakMap, Set, WeakSet

원시 타입과 참조 타입의 차이점은 '불변성(immutability)' 에 있다.

## 02 데이터 타입에 관한 배경지식
불변성을 제대로 이해하기 위해 자바스크립트가 메모리 영역에서 어떻게 처리되는지 알아보자!

### 메모리와 데이터
컴퓨터가 메모리에 데이터를 저장하는 방법을 알아보기 이전에 이해해야할 부분은 아래와 같다.

0 또는 1만 표현할 수 있는 하나의 메모리 조각을 비트(bit)라고 한다. 각 비트는 고유한 식별자(unique identifier)를 통해 위치를 확인할 수 있다.

C/C++, 자바 등의 언어는 데이터 타입별로 할당할 메모리의 영역을 2바이트, 4바이트 등으로 정해놨다.
예를 들어, 정수형 타입(short)은 2바이트 크기이므로 표현할 수 있는 값의 범위가 0을 포함해 -32768 ~ +32767 이다.
만약 사용자가 위 범위에 벗어나는 숫자를 입력하는 경우 오류가 발생한다. 오류를 해결하기 위해서 사용자가 직접 4바이트 크기에 해당하는 정수형(int) 로 직접 형변환을 해줘야 한다.

자바스크립트가 등장할때는 보다 더 넉넉한 메모리 공간을 사용할 수 있게 되었다.
숫자의 경우 64비트, 즉 8바이트를 확보할 수 있게 됐다.

비트가 고유한 식별자로 위치를 확인할 수 있듯이 바이트는 '메모리 주솟갓(memory address)' 를 통해 서로 구분하거나 연결할 수 있다.

### 식별자와 변수
변수와 식별자는 어떻게 다를까?
변수는 "변할 수 있는 데이터", 식별자는 어떤 데이터를 식별하기 위해 사용하는 이름, 즉 변수명을 뜻한다.

## 03 변수 선언과 데이터 할당
### 변수 선언

변수란 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇이라고 생각할 수 있다.
변수를 선언하면 컴퓨터는 메모리에서 비어있는 공간 하나를 확보하고, 이 공간의 이름을 식별자로 지정한다.

```
var a;
```

위의 변수 선언은 아래와 같이 메모리에 할당되는 것으로 개략적으로 표현할 수 있다.

|주소|...|1002|1003|1004|1005|...|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|데이터|||이름: a,  값: ||||

사용자가 a에 접근하고자 하면 컴퓨터는 메모리에서 a의 이름을 가진 주소를 검색하여 해당 공간에 담긴 데이터를 반환한다.

### 데이터 할당

하지만 실제로는 a라는 이름을 가진 주소에 데이터를 '직접' 저장하지는 않는다. 데이터를 저장하기 위한 별도의 공간을 다시 확보한 뒤 데이터를 저장하고, 그 주소를 변수 영역에 저장하는 방식이다.

|주소|...|1002|1003|1004|1005|...|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|데이터|||이름: a,  값:@5004 ||||
|주소|...|5002|5003|5004|5005|...|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|데이터||||'abc'|||

1. 변수 영역에서 빈 공간(@1003)을 확보한다.
2. 확보한 공간의 식별자를 a로 지정한다.
3. 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장한다.
4. 변수 영역에서 a라는 식별자를 검색한다(@1003)
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다.

왜 변수 영역에 데이터를 직접 대입하지 않고 한 단계 더 거쳐서 처리하는걸까?
만약 메모리 영역의 중간 데이터를 늘려야한다면 확보된 공간보다 커진 데이터를 처리하기 위해 컴퓨터가 처리해야 할 연산이 많아질 수 있다. 결국 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.

예를 들어, 500개의 변수에 대해 5라는 숫자를 할당하는 상황을 가정해보자.
각 변수를 별개로 인식하기 위해 500개의 변수는 각각의 저장 공간을 확보해야 한다.
500개의 변수에 5라는 숫자를 각각의 공간에 할당하기 위해서는 총 4000바이트가 필요한다. (변수 500개 * 숫자형의 크기 8바이트)
위의 방식 대신에 5라는 숫자 데이터를 한 공간에만 저장하고, 해당 주소만 사용한다면, 예를 들어 주소 공간의 크기가 2바이트라고 가정한다면 1008 바이트만 사용하면 된다. (데이터 영역에 저장: 변수 500개 * 주소 공간의 크기 2바이트 + 변수 영역에 저장: 숫자형의 크기 8바이트)

따라서, 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다.


|주소|...|1002|1003|1004|1005|...|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|데이터|||이름: a,  값:@5005 ||||
|주소|...|5002|5003|5004|5005|...|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|데이터||||'abc'|'abcdef'||

만약 위와 같이 식별자 a의 데이터에 'abcdef'를 재할당하는 경우 기존에 'abc'가 저장되었던 공간에 'abcdef'를 할당하는 것이 아니라, 'abcdef'라는 문자열을 새로 만들어 별도의 공간에 저장하고, 새로 저장된 공간의 주소를 변수 공간에 연결한다.
기존 문자열에 어떤 변환을 가하든(문자를 추가 및 제거) 상관 없이 무조건 '새로' 만들어서 별도의 공간에 저장한다.

## 04 기본형 데이터와 참조형 데이터
### 불변값
변수(variable)와 상수(constant)를 구분하는 성질은 '변경 가능성'이다.
그리고 이 변경 가능성은 **'변수 영역 메모리'**에 대한 변경 가능성을 의미한다.
한 번 데이터 할당이 이뤄진 변수 공간에 대해 다른 데이터를 재할당할 수 있는지의 여부에 의해 변경 가능성을 판단한다.

반면에 불변성의 여부는 '데이터 영역 메모리' 가 변경 가능성의 대상이 된다.

원시 타입에 해당하는 숫자, 문자열, boolean, null, undeinfed, Symbol은 모두 불변값이다.
```
var a = 'abc';
a = a + 'def';
var b = 5;
var c = 5;
b = 7;
```

앞서 살펴봤듯이 변수 a에 'abc'를 할당했다가 'def'를 추가하면 기존의 'abc'가 'abcdef'로 바뀌는 것이 아니다. 새로운 문자열 'abcdef'가 데이터 영역에 저장되고 해당 데이터의 주솟값이 변수 a에 저장된다.
즉, 'abc'와 'abcdef'는 완전히 별개의 데이터이다.

변수 b에 5를 할당한 후에 변수 c에 또 숫자 5를 할당하려고 한다. 컴퓨터는 데이터 영역에서 5를 찾는다. 이미 5라는 데이터가 저장된 공간이 있기 때문에 해당 주소를 재활용하여 변수 c에 저장한다.

변수 b의 값을 7로 변경하려고 한다. 마찬가지로 기존에 데이터 영역에 저장되었던 5가 7로 변경되는 것이 아니라, 숫자 7을 저장하기 위한 별도의 공간이 생긴다.

위 예제에서 살펴볼 수 있듯이 데이터 영역에 저장된 문자열 'abc', 숫자 5 자체를 다른 데이터로 변경하는 것이 아니다. 이것이 바로 '불변성' 이다. 한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

### 가변값
원시 타입 데이터는 모두 '불변값'이다. 그렇다면 참조 타입 데이터는 모두 가변값일까?
기본적인 성질은 가변적이지만, 설정에 따라 불가능한 경우도 있고(Object.defineProperty, Object.freeze 등), 아예 불변값으로 활용할 수 있는 방안도 있다.

참조형 데이터를 변수에 할당하는 과정은 아래와 같다.

```
var obj1 = {
  a: 1,
  b: 'bbb
}
```